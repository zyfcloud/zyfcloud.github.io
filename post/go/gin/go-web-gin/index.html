<!DOCTYPE html>
<html  dir="ltr" lang="en" data-theme=""><head>
    <title> zyfcloud | golang:gin和net/http </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.81.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="gin，beego等底层都用的是net/http模块，上篇文章中对一个基本的http请求作了分析，这篇文章就gin怎么用的http模块的流程进行梳理。">
    
    
    
    <link rel="stylesheet"
        href="/css/style.min.51d7ec6db610dce512b735d5315f963c278042d026aa4ebe05a9355460b49016.css"
        integrity="sha256-UdfsbbYQ3OUStzXVMV&#43;WPCeAQtAmqk6&#43;Bak1VGC0kBY="
        crossorigin="anonymous"
        type="text/css">
    
    
    <link rel="stylesheet"
        href="/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css"
        integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS&#43;yuWSR4="
        crossorigin="anonymous"
        type="text/css">
    
    <link rel="stylesheet" 
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" 
    integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" 
    crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

    <link rel="canonical" href="/post/go/gin/go-web-gin/">

    
    
    
    
    <script type="text/javascript"
            src="/js/anatole-header.min.0c05c0a90d28c968a1cad4fb31abd0b8e1264e788ccefed022ae1d3b6f627514.js"
            integrity="sha256-DAXAqQ0oyWihytT7MavQuOEmTniMzv7QIq4dO29idRQ="
            crossorigin="anonymous"></script>


    
        
        
        <script type="text/javascript"
                src="/js/anatole-theme-switcher.min.7fd87181cdd7e8413aa64b6867bb32f3a8dc242e684fc7d5bbb9f600dbc2b6eb.js"
                integrity="sha256-f9hxgc3X6EE6pktoZ7sy86jcJC5oT8fVu7n2ANvCtus="
                crossorigin="anonymous"></script>
    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="golang:gin和net/http"/>
<meta name="twitter:description" content="gin，beego等底层都用的是net/http模块，上篇文章中对一个基本的http请求作了分析，这篇文章就gin怎么用的http模块的流程进行梳理。"/>


    

</head>
<body><div class="sidebar animated fadeInDown ">
    <div class="logo-title">
        <div class="title">
            <img src="/images/profile.png" alt="profile picture">
            <h3 title=""><a href="/">ZYF-CLOUD</a></h3>
            <div class="description">
                <p>some sharing</p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
    </ul>
    <div class="footer">
        <div class="by_farbox">&copy; zyfcloud  2021 </div>
    </div>
</div>
<div class="main">
    <div class="page-top  animated fadeInDown ">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href="/"
                        
                   title="">Home</a></li>
        
            
            <li><a 
                   href="/post/"
                        
                   title="">Posts</a></li>
        
            
            <li><a 
                   href="/about/"
                        
                   title="">About</a></li>
        
        
        
            <li class="theme-switch-item">
                <a class="theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
    <div class="post  animated fadeInDown ">
        <div class="post-content">
            
            <div class="post-title">
                <h3>golang:gin和net/http</h3>
                
                    <div class="info">
                        <em class="fas fa-calendar-day"></em>
                        <span class="date"> Sun, May 5, 2019 
                                           </span>
                        <em class="fas fa-stopwatch"></em>
                        <span class="reading-time">5-minute read</span>
                    </div>
                
            </div>

            <p>gin，beego等web框架底层都用的是net/http模块，接上一篇文章，本文就gin怎么用net/http起web服务进行梳理。</p>
<h4 id="一个基本的gin项目代码">一个基本的gin项目代码：</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;github.com/gin-gonic/gin&#34;</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">Default</span>()
	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/ping&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">Context</span>) {
		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">JSON</span>(<span style="color:#ae81ff">200</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">H</span>{<span style="color:#e6db74">&#34;message&#34;</span>: <span style="color:#e6db74">&#34;pong&#34;</span>,})
	})
	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Run</span>() <span style="color:#75715e">// listen and serve on 0.0.0.0:8080 (for windows &#34;localhost:8080&#34;)
</span><span style="color:#75715e"></span>}
</code></pre></div><p>可以看到一个基本的启动过程：</p>
<p>（1）首先生成一个gin.Default</p>
<p>（2）设置路由r.GET&hellip;</p>
<p>（3）启动listen and serve</p>
<p>例行先提出问题：</p>
<p>（q1）gin是怎么使用到net/http的模块的？</p>
<p>（q2）gin的路由处理流程？</p>
<p>通过每个流程的分析来解答：</p>
<h4 id="一gindefault">一、gin.Default</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Default returns an Engine instance with the Logger and Recovery middleware already attached.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Default</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Engine</span> {
	<span style="color:#a6e22e">debugPrintWARNINGDefault</span>()        <span style="color:#75715e">// go版本的校验（&gt;1.8.x）,debugPrint,debug模式的时候会有相关打印
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">engine</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">New</span>()              <span style="color:#75715e">// 生成一个Engine结构体
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">Logger</span>(), <span style="color:#a6e22e">Recovery</span>())        <span style="color:#75715e">// 用了Logger和Recovery两个middleware，同时也可以自己定义middleware
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">engine</span>        <span style="color:#75715e">// 返回结构体
</span><span style="color:#75715e"></span>}
</code></pre></div><h5 id="11-debugprintwarningdefault">1.1 debugPrintWARNINGDefault：</h5>
<p>关于版本的校验等信息，debug模式下的启动日志打印</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrintWARNINGDefault</span>() {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getMinVer</span>(<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Version</span>()); <span style="color:#a6e22e">e</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">ginSupportMinGoVer</span> {                          <span style="color:#75715e">//  版本的校验，不能小于1.8
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">debugPrint</span>(<span style="color:#e6db74">`[WARNING] Now Gin requires Go 1.8 or later and Go 1.9 will be required soon.
</span><span style="color:#e6db74">`</span>)}
	<span style="color:#a6e22e">debugPrint</span>(<span style="color:#e6db74">`[WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.
</span><span style="color:#e6db74">`</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getMinVer</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">uint64</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">first</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">IndexByte</span>(<span style="color:#a6e22e">v</span>, <span style="color:#e6db74">&#39;.&#39;</span>)
	<span style="color:#a6e22e">last</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">LastIndexByte</span>(<span style="color:#a6e22e">v</span>, <span style="color:#e6db74">&#39;.&#39;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">first</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">last</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">first</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">last</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">ParseUint</span>(<span style="color:#a6e22e">v</span>[<span style="color:#a6e22e">first</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:], <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">64</span>)
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">ParseUint</span>(<span style="color:#a6e22e">v</span>[<span style="color:#a6e22e">first</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:<span style="color:#a6e22e">last</span>], <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">64</span>)
}
</code></pre></div><h5 id="12-engine--new">1.2 engine := New()</h5>
<p>New函数用于生成一个新的Engine结构体，可以看到各种参数配置</p>
<p>首先我们来关注Engine结构体的几个参数：</p>
<p>（1）RouterGroup：RouterGroup 描述的一个路由组，其中包含了这个路由组的相关公共属性，比如后面可以通过(group *RouterGroup) Group方法修改basePath字段，用于加一些公共的路由前缀(eg:&ldquo;api/v1&rdquo;)，。通过(group *RouterGroup) Use(middleware &hellip;HandlerFunc)方法改变Handlers字段，用于添加公共的中间件。</p>
<p>贴一段项目代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// InsecureRouterGroup returns router group without auth
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">InsecureRouterGroup</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">RouterGroup</span> {
	<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gEngine</span>.<span style="color:#a6e22e">Group</span>(<span style="color:#a6e22e">constants</span>.<span style="color:#a6e22e">APIVERSION</span>)
	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">RequestID</span>)
	<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Unlock</span>()
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span>
}
</code></pre></div><p>（2）各种bool参数，用于对重定向（redirect），转发（ForwardedByClientIP）等一些属性的控制</p>
<p>（3）trees：类型为methodTrees，是每个不同方法的路由集合，原理参考go的http/router框架。大致就是一个路由查找树，用到了radix tree(前缀树）或者说是压缩检索树的数据结构，来进行路由匹配，可以大大的提高路由查找的效率。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">methodTrees</span> []<span style="color:#a6e22e">methodTree</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">methodTree</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">method</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">root</span>   <span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>
}
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">path</span>      <span style="color:#66d9ef">string</span>              <span style="color:#75715e">// 当前节点的对应的子查找路径
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">indices</span>   <span style="color:#66d9ef">string</span>              <span style="color:#75715e">// 子节点的首字母的组成的字符串
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">children</span>  []<span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>            <span style="color:#75715e">// 子节点
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">handlers</span>  <span style="color:#a6e22e">HandlersChain</span>     <span style="color:#75715e">// 这个node对应要处理的Handlers
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">priority</span>  <span style="color:#66d9ef">uint32</span>
	<span style="color:#a6e22e">nType</span>     <span style="color:#a6e22e">nodeType</span>      <span style="color:#75715e">// 当前节点类型（eg: root(根节点)/default(普通的)/param(参数类型)/catchAll(通配符)）
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">maxParams</span> <span style="color:#66d9ef">uint8</span>
	<span style="color:#a6e22e">wildChild</span> <span style="color:#66d9ef">bool</span>        <span style="color:#75715e">// 当前节点的子节点是否是参数节点
</span><span style="color:#75715e"></span>}
</code></pre></div><p>（4）pool：sync.Pool类型，New方法定义为return engine.allocateContext()，返回的结构体是gin.Context结构体，便于对结构体的复用，减少gc。</p>
<p>抛出问题</p>
<p>（qa6）：gin.Context结构体在哪里被用到的？具体的代码处理逻辑？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">New</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Engine</span> {
	<span style="color:#a6e22e">debugPrintWARNINGNew</span>()
	<span style="color:#a6e22e">engine</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Engine</span>{
		<span style="color:#a6e22e">RouterGroup</span>: <span style="color:#a6e22e">RouterGroup</span>{
			<span style="color:#a6e22e">Handlers</span>: <span style="color:#66d9ef">nil</span>,        <span style="color:#75715e">// 这个路由组的公共hanlers，后面会给其加上middleware
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">basePath</span>: <span style="color:#e6db74">&#34;/&#34;</span>,      <span style="color:#75715e">// 路由地址为&#34;/&#34;
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">root</span>:     <span style="color:#66d9ef">true</span>,         <span style="color:#75715e">// 表明这个为根路由
</span><span style="color:#75715e"></span>		},
		<span style="color:#a6e22e">FuncMap</span>:                <span style="color:#a6e22e">template</span>.<span style="color:#a6e22e">FuncMap</span>{},
		<span style="color:#a6e22e">RedirectTrailingSlash</span>:  <span style="color:#66d9ef">true</span>,
		<span style="color:#a6e22e">RedirectFixedPath</span>:      <span style="color:#66d9ef">false</span>,
		<span style="color:#a6e22e">HandleMethodNotAllowed</span>: <span style="color:#66d9ef">false</span>,
		<span style="color:#a6e22e">ForwardedByClientIP</span>:    <span style="color:#66d9ef">true</span>,
		<span style="color:#a6e22e">AppEngine</span>:              <span style="color:#a6e22e">defaultAppEngine</span>,
		<span style="color:#a6e22e">UseRawPath</span>:             <span style="color:#66d9ef">false</span>,
		<span style="color:#a6e22e">UnescapePathValues</span>:     <span style="color:#66d9ef">true</span>,
		<span style="color:#a6e22e">MaxMultipartMemory</span>:     <span style="color:#a6e22e">defaultMultipartMemory</span>,
		<span style="color:#a6e22e">trees</span>:                  make(<span style="color:#a6e22e">methodTrees</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">9</span>),              <span style="color:#75715e">// 给methodTrees定义一个methodTree的数组
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">delims</span>:                 <span style="color:#a6e22e">render</span>.<span style="color:#a6e22e">Delims</span>{<span style="color:#a6e22e">Left</span>: <span style="color:#e6db74">&#34;{{&#34;</span>, <span style="color:#a6e22e">Right</span>: <span style="color:#e6db74">&#34;}}&#34;</span>},
		<span style="color:#a6e22e">secureJsonPrefix</span>:       <span style="color:#e6db74">&#34;while(1);&#34;</span>,
	}
	<span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">RouterGroup</span>.<span style="color:#a6e22e">engine</span> = <span style="color:#a6e22e">engine</span>
	<span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">pool</span>.<span style="color:#a6e22e">New</span> = <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">interface</span>{} {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">allocateContext</span>()
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">engine</span>
}
</code></pre></div><p>抛出问题：
（q3）路由查找的时候RouterGroup和trees都是在哪里被用到了？</p>
<h5 id="13-engineuselogger-recovery">1.3 engine.Use(Logger(), Recovery())</h5>
<p>这里用了gin的中间件Logger和Recovery</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Use attaches a global middleware to the router. ie. the middleware attached though Use() will be
</span><span style="color:#75715e">// included in the handlers chain for every single request. Even 404, 405, static files...
</span><span style="color:#75715e">// For example, this is the right place for a logger or error management middleware.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">engine</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Engine</span>) <span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">middleware</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">HandlerFunc</span>) <span style="color:#a6e22e">IRoutes</span> {
	<span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">RouterGroup</span>.<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">middleware</span><span style="color:#f92672">...</span>)        <span style="color:#75715e">// use中间件，把加入的middleware加入到engine.RouterGroup.Handlers中，在后面加入具体的业务代码的时候会combine这个Handlers和具体的业务handler，解释了(qa3)的问题。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">rebuild404Handlers</span>()          <span style="color:#75715e">// 用于重写noroute的handler,具体的方法实现在func (engine *Engine) NoRoute(handlers ...HandlerFunc)中，用于用户自己定义
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">rebuild405Handlers</span>()      <span style="color:#75715e">// 同上，用于重写nomethod的handler
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">engine</span>
}
<span style="color:#75715e">// Use adds middleware to the group, see example code in GitHub.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">group</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RouterGroup</span>) <span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">middleware</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">HandlerFunc</span>) <span style="color:#a6e22e">IRoutes</span> {
	<span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">Handlers</span> = append(<span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">Handlers</span>, <span style="color:#a6e22e">middleware</span><span style="color:#f92672">...</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">returnObj</span>()
}
</code></pre></div><p>至此对于gin.Default的代码分析完毕</p>
<h4 id="二rgetping-funcc-gincontext-cjson200-ginhmessagepong-">二、r.GET(&quot;/ping&quot;, func(c *gin.Context) {c.JSON(200, gin.H{&ldquo;message&rdquo;:&ldquo;pong&rdquo;,}) })</h4>
<p>先贴源码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// GET is a shortcut for router.Handle(&#34;GET&#34;, path, handle).
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">group</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RouterGroup</span>) <span style="color:#a6e22e">GET</span>(<span style="color:#a6e22e">relativePath</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">handlers</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">HandlerFunc</span>) <span style="color:#a6e22e">IRoutes</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">handle</span>(<span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#a6e22e">relativePath</span>, <span style="color:#a6e22e">handlers</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">group</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RouterGroup</span>) <span style="color:#a6e22e">handle</span>(<span style="color:#a6e22e">httpMethod</span>, <span style="color:#a6e22e">relativePath</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">handlers</span> <span style="color:#a6e22e">HandlersChain</span>) <span style="color:#a6e22e">IRoutes</span> {
	<span style="color:#a6e22e">absolutePath</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">calculateAbsolutePath</span>(<span style="color:#a6e22e">relativePath</span>) <span style="color:#75715e">// 合并相对路径和routerGroup的basePath
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">handlers</span> = <span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">combineHandlers</span>(<span style="color:#a6e22e">handlers</span>) <span style="color:#75715e">// 把业务的handler和共用的handler（middleware）结合到一起，返回一个新的HandlersChain
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">addRoute</span>(<span style="color:#a6e22e">httpMethod</span>, <span style="color:#a6e22e">absolutePath</span>, <span style="color:#a6e22e">handlers</span>) <span style="color:#75715e">// 把path加入到相应的method的检索树中去，关联相应的handlers
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">returnObj</span>()
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">group</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RouterGroup</span>) <span style="color:#a6e22e">calculateAbsolutePath</span>(<span style="color:#a6e22e">relativePath</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">joinPaths</span>(<span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">basePath</span>, <span style="color:#a6e22e">relativePath</span>)
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">group</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RouterGroup</span>) <span style="color:#a6e22e">combineHandlers</span>(<span style="color:#a6e22e">handlers</span> <span style="color:#a6e22e">HandlersChain</span>) <span style="color:#a6e22e">HandlersChain</span> {
	<span style="color:#a6e22e">finalSize</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">Handlers</span>) <span style="color:#f92672">+</span> len(<span style="color:#a6e22e">handlers</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">finalSize</span> <span style="color:#f92672">&gt;=</span> int(<span style="color:#a6e22e">abortIndex</span>) {
		panic(<span style="color:#e6db74">&#34;too many handlers&#34;</span>)
	}
	<span style="color:#a6e22e">mergedHandlers</span> <span style="color:#f92672">:=</span> make(<span style="color:#a6e22e">HandlersChain</span>, <span style="color:#a6e22e">finalSize</span>)
	copy(<span style="color:#a6e22e">mergedHandlers</span>, <span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">Handlers</span>)
	copy(<span style="color:#a6e22e">mergedHandlers</span>[len(<span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">Handlers</span>):], <span style="color:#a6e22e">handlers</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">mergedHandlers</span>
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">engine</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Engine</span>) <span style="color:#a6e22e">addRoute</span>(<span style="color:#a6e22e">method</span>, <span style="color:#a6e22e">path</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">handlers</span> <span style="color:#a6e22e">HandlersChain</span>) {
	<span style="color:#a6e22e">assert1</span>(<span style="color:#a6e22e">path</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;/&#39;</span>, <span style="color:#e6db74">&#34;path must begin with &#39;/&#39;&#34;</span>)
	<span style="color:#a6e22e">assert1</span>(<span style="color:#a6e22e">method</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#e6db74">&#34;HTTP method can not be empty&#34;</span>)
	<span style="color:#a6e22e">assert1</span>(len(<span style="color:#a6e22e">handlers</span>) &gt; <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;there must be at least one handler&#34;</span>)

	<span style="color:#a6e22e">debugPrintRoute</span>(<span style="color:#a6e22e">method</span>, <span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">handlers</span>)
	<span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">trees</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">method</span>)      <span style="color:#75715e">// 查看engine.trees是否已经有了此method，没有的话创建出一个新的method的node
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">root</span> = new(<span style="color:#a6e22e">node</span>)
		<span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">trees</span> = append(<span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">trees</span>, <span style="color:#a6e22e">methodTree</span>{<span style="color:#a6e22e">method</span>: <span style="color:#a6e22e">method</span>, <span style="color:#a6e22e">root</span>: <span style="color:#a6e22e">root</span>})
	}
	<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">addRoute</span>(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">handlers</span>)        <span style="color:#75715e">// 把handlers加入到method的node中
</span><span style="color:#75715e"></span>}
</code></pre></div><p>总结：r.GET方法工作（1）合并拿到绝对路径 （2）将业务handler和middle handler合并为mergeHandler（3）将路径，mergeHandler，method（httprouter的节点相关元素）加入到methodTrees中。</p>
<p>总的来说处理过程符合httprouter那一套逻辑。</p>
<h4 id="三rrun">三、r.Run()</h4>
<p>现在我们已经有了一个类型为Engine的handler（实现了ServeHTTP的方法），以及一个Engine里的路由检索树已经建立好了。
抛出问题</p>
<p>（qa4）：对于进来的请求怎么进行监听的？</p>
<p>（qa5）：对于路由的匹配是在哪里进行的？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Run attaches the router to a http.Server and starts listening and serving HTTP requests.
</span><span style="color:#75715e">// It is a shortcut for http.ListenAndServe(addr, router)
</span><span style="color:#75715e">// Note: this method will block the calling goroutine indefinitely unless an error happens.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">engine</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Engine</span>) <span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">addr</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">string</span>) (<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">debugPrintError</span>(<span style="color:#a6e22e">err</span>) }()
	<span style="color:#a6e22e">address</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">resolveAddress</span>(<span style="color:#a6e22e">addr</span>)
	<span style="color:#a6e22e">debugPrint</span>(<span style="color:#e6db74">&#34;Listening and serving HTTP on %s\n&#34;</span>, <span style="color:#a6e22e">address</span>)
	<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">engine</span>)
	<span style="color:#66d9ef">return</span>
}

<span style="color:#75715e">// ListenAndServe listens on the TCP network address addr and then calls
</span><span style="color:#75715e">// Serve with handler to handle requests on incoming connections.
</span><span style="color:#75715e">// Accepted connections are configured to enable TCP keep-alives.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// The handler is typically nil, in which case the DefaultServeMux is used.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// ListenAndServe always returns a non-nil error.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#a6e22e">addr</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">handler</span> <span style="color:#a6e22e">Handler</span>) <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">server</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Server</span>{<span style="color:#a6e22e">Addr</span>: <span style="color:#a6e22e">addr</span>, <span style="color:#a6e22e">Handler</span>: <span style="color:#a6e22e">handler</span>}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">ListenAndServe</span>()
}
</code></pre></div><p>可以看到这里的Run即为将engine这个handler放入到http.ListenAndServe中去，然后启用监听。。。。，监听流程和net/http的处理流程一致。（解答了qa4）</p>
<p>对于qa5：</p>
<p>首选回顾一下,net/http中的路由查找是怎么执行的吗？看下面的代码，其实发现net/http用的是ServeMux这个handler，也是实现了ServeHTTP这个方法，具体的路由匹配在mux.Handler(r) 中</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">mux</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ServeMux</span>) <span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Request</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">RequestURI</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;*&#34;</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">ProtoAtLeast</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>) {
            <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Header</span>().<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;Connection&#34;</span>, <span style="color:#e6db74">&#34;close&#34;</span>)
        }
        <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">WriteHeader</span>(<span style="color:#a6e22e">StatusBadRequest</span>)
        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#a6e22e">h</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mux</span>.<span style="color:#a6e22e">Handler</span>(<span style="color:#a6e22e">r</span>)                  <span style="color:#75715e">//  handler的路由处理
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">r</span>)                       <span style="color:#75715e">//  ServeHTTP的实现，对应到用户的业务逻辑处理
</span><span style="color:#75715e"></span>}
</code></pre></div><p>而engine即类似于ServeMux，也实现了一个ServeHTTP方法，也是在方法里进行了路由的匹配以及具体逻辑的处理，详细见下面代码。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// ServeHTTP conforms to the http.Handler interface。
</span><span style="color:#75715e">// 这个方法的实现是在一个goroutine中实现的，就是说每对一个新的HTTP请求，都会生成一个新的goroutine去处理（并发处理详见net/http的处理过程）。
</span><span style="color:#75715e">//对于这个HTTP请求，会先触发ServeHTTP方法得到一个Context请求上下文，然后调用engine.handleHTTPRequest(C)，处理这个请求，同时将处理的内容写入到http.ResponseWriter中。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">engine</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Engine</span>) <span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">pool</span>.<span style="color:#a6e22e">Get</span>().(<span style="color:#f92672">*</span><span style="color:#a6e22e">Context</span>)      <span style="color:#75715e">// 从池子里拿出来，要是没有了的话自己new一个出来。有并发请求进来的时候，会产生多个context
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">writermem</span>.<span style="color:#a6e22e">reset</span>(<span style="color:#a6e22e">w</span>)      <span style="color:#75715e">// 对context的ResponseWriter赋为w
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Request</span> = <span style="color:#a6e22e">req</span>            <span style="color:#75715e">// 对context的Request赋为req
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">reset</span>()        <span style="color:#75715e">// 对拿到的context进行reset，类似于清空，然后才进行使用
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">handleHTTPRequest</span>(<span style="color:#a6e22e">c</span>)      <span style="color:#75715e">// 这里就是最后的逻辑处理，包括（1）通过context .Request.path找到对应的handler   （2）middleware的执行 （3）业务代码的执行 （4）写入结果到context. ResponseWriter中去
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">pool</span>.<span style="color:#a6e22e">Put</span>(<span style="color:#a6e22e">c</span>)        <span style="color:#75715e">// 用完了之后放回到engine.pool中去
</span><span style="color:#75715e"></span>}
</code></pre></div><p>注释解释了qa6。</p>
<p>对于engine.handleHTTPRequest(c)中的处理逻辑，涉及到了middleware的处理，下面拉出来分析一下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">engine</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Engine</span>) <span style="color:#a6e22e">handleHTTPRequest</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Context</span>) {
	<span style="color:#a6e22e">httpMethod</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Request</span>.<span style="color:#a6e22e">Method</span>
	<span style="color:#a6e22e">rPath</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Request</span>.<span style="color:#a6e22e">URL</span>.<span style="color:#a6e22e">Path</span>
	<span style="color:#a6e22e">unescape</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">UseRawPath</span> <span style="color:#f92672">&amp;&amp;</span> len(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Request</span>.<span style="color:#a6e22e">URL</span>.<span style="color:#a6e22e">RawPath</span>) &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">rPath</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Request</span>.<span style="color:#a6e22e">URL</span>.<span style="color:#a6e22e">RawPath</span>
		<span style="color:#a6e22e">unescape</span> = <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">UnescapePathValues</span>
	}
	<span style="color:#a6e22e">rPath</span> = <span style="color:#a6e22e">cleanPath</span>(<span style="color:#a6e22e">rPath</span>)
	<span style="color:#75715e">// Find root of the tree for the given HTTP method
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">trees</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">tl</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">t</span>); <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">tl</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">method</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">httpMethod</span> {         <span style="color:#75715e">// 遍历methodTrees，找到当前方法的methodTree   
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">continue</span>
		}
		<span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">root</span>                <span style="color:#75715e">// 找到methodTree的root
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Find route in tree
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">handlers</span>, <span style="color:#a6e22e">params</span>, <span style="color:#a6e22e">tsr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">getValue</span>(<span style="color:#a6e22e">rPath</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Params</span>, <span style="color:#a6e22e">unescape</span>)        <span style="color:#75715e">// 拿到当前tree下的这个路径下的handler和参数等
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">handlers</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">handlers</span> = <span style="color:#a6e22e">handlers</span>
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Params</span> = <span style="color:#a6e22e">params</span>
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Next</span>()              <span style="color:#75715e">// 这里是真正的进行handler的执行，包括middleware和业务handle
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">writermem</span>.<span style="color:#a6e22e">WriteHeaderNow</span>()        <span style="color:#75715e">// 写入header
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span>  
		}
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">httpMethod</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;CONNECT&#34;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">rPath</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;/&#34;</span> {          <span style="color:#75715e">// 跨域等操作
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tsr</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">RedirectTrailingSlash</span> {
				<span style="color:#a6e22e">redirectTrailingSlash</span>(<span style="color:#a6e22e">c</span>)
				<span style="color:#66d9ef">return</span>
			}
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">RedirectFixedPath</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">redirectFixedPath</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">RedirectFixedPath</span>) {
				<span style="color:#66d9ef">return</span>
			}
		}
		<span style="color:#66d9ef">break</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">HandleMethodNotAllowed</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">tree</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">trees</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">method</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">httpMethod</span> {
				<span style="color:#66d9ef">continue</span>
			}
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">handlers</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">getValue</span>(<span style="color:#a6e22e">rPath</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">unescape</span>); <span style="color:#a6e22e">handlers</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">handlers</span> = <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">allNoMethod</span>
				<span style="color:#a6e22e">serveError</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">StatusMethodNotAllowed</span>, <span style="color:#a6e22e">default405Body</span>)
				<span style="color:#66d9ef">return</span>
			}
		}
	}
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">handlers</span> = <span style="color:#a6e22e">engine</span>.<span style="color:#a6e22e">allNoRoute</span>
	<span style="color:#a6e22e">serveError</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">StatusNotFound</span>, <span style="color:#a6e22e">default404Body</span>)
}

<span style="color:#75715e">// Next should be used only inside middleware.
</span><span style="color:#75715e">// It executes the pending handlers in the chain inside the calling handler.
</span><span style="color:#75715e">// See example in GitHub.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Context</span>) <span style="color:#a6e22e">Next</span>() {
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">index</span> &lt; int8(len(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">handlers</span>)) {
		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">handlers</span>[<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">index</span>](<span style="color:#a6e22e">c</span>)                        <span style="color:#75715e">// 会进行递归执行middleware，直到执行到业务代码。一般的middleware会有个c.Next方法。像cors等没有写c.Next的，其实在for c.index &lt; int8(len(c.handlers))遍历中也会被执行到。
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
	}
}
</code></pre></div><p>可以看到在handleHTTPRequest执行过程中，都是通过context结构体进行上下文传递的，传递的内容包括Request，Writer，handlers，Params等等。</p>
<h4 id="总结">总结：</h4>
<p>至此可以看到gin作为一个web框架，其实就是重写了原生的ServeMux的实现。Engine就是一个类似于ServeMux的handler。</p>
<p>基本的web实现的时候，重新实现的逻辑主要有：</p>
<p>（1）对于路由的查找，用了http/router的路由框架，并在ServeHTTP方法中进行了路由的查找。</p>
<p>（2）用了中间件的处理逻辑，并在路由添加的时候进行了路由的合并等操作，并且在handleHTTPRequest的时候也会对每个中间件进行处理。</p>
<p>后面有新的发现进行补充。。。</p>
</div>
        <div class="post-footer">
            <div class="info">
                <span class="separator"><a class="category" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span>
                <span class="separator"><a class="tag" href="/tags/go/">go</a><a class="tag" href="/tags/gin/">gin</a></span>
            </div>
        </div>

        
    </div>


        </div>
    </div>
</div>

<script type="text/javascript"
        src="/js/medium-zoom.min.2d6fd0be87fa98f0c9b4dc2536b312bbca48757f584f6ea1f394abc9bcc38fbc.js"
        integrity="sha256-LW/Qvof6mPDJtNwlNrMSu8pIdX9YT26h85SrybzDj7w="
        crossorigin="anonymous"></script></body>

</html>
